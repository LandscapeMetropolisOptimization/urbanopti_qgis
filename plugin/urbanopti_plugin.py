# -*- coding: utf-8 -*-
"""
/***************************************************************************
 UrbanOptiPlugin
                                 A QGIS plugin
 Design Urban Mobility networks via Optimization
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2020-11-15
        git sha              : $Format:%H$
        copyright            : (C) 2020 by Pietro Belotti
        email                : pietro.belotti@polimi.it
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication
from qgis.PyQt.QtGui import QIcon, QColor
from qgis.PyQt.QtWidgets import QAction, QFileDialog

from qgis.core import *

# Initialize Qt resources from file resources.py
from .resources import *

# Import the code for the dialog
from .urbanopti_plugin_dialog import UrbanOptiPluginDialog

import os.path
import datetime as dt

from qgis.core import QgsProject, Qgis, QgsVectorLayer, \
  QgsLayerTreeGroup, QgsLayerTreeLayer

from urbanopti.greentransport.optmodel import OptModel, add_cumul_flow_layer

from .instance import UrbanData


def get_layer_names(group):
    """recursively return all layers and their children
    """
    layerlist = []
    for l in group.children():
        if isinstance(l, QgsLayerTreeLayer):
            layerlist.append(l.layer().name())
        else:
            layerlist.extend(get_layer_names(l))
    return layerlist


class UrbanOptiPlugin:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """

        # Save reference to the QGIS interface
        self.iface = iface

        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            os.path.dirname(__file__),
            'i18n',
            'UrbanOptimizer_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&Urban Optimizer')

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('UrbanOptiPlugin', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action


    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/urbanopti_plugin/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'Urban mobility planner'),
            callback=self.run,
            parent=self.iface.mainWindow())

        # will be set False in run()
        self.first_start = True


    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&Urban Optimizer'),
                action)
            self.iface.removeToolBarIcon(action)


    def select_output_file(self):
        filename, _filter = QFileDialog.getSaveFileName(
            self.mipdlg, "Select output file ", "", '*.csv')
        self.mipdlg.lineEdit_4.setText(filename)


    def addSolutionLayer(self, sol):

        solgroup = QgsLayerTreeGroup('Soluzione {}'.format(dt.datetime.now()))

        root = QgsProject.instance().layerTreeRoot()
        root.insertChildNode(1, solgroup)   # 1 is position in layer directory

        layer_name = {"trail_end":  self.modeldlg.trailPointLayer.currentText(),
                      "landing":    self.modeldlg.canalPointLayer.currentText(),
                      "railway_st": self.modeldlg.railwayPointLayer.currentText()}

        # Add node layers
        for feat_key in sol['nodes']:

            # feat_key is one of "canal", "railway_st", and "trail_end".

            if len(sol['nodes'][feat_key]) == 0:
                continue

            layer = QgsProject.instance().mapLayersByName(layer_name[feat_key])[0]
            attr = layer.dataProvider().fields().toList()

            layer_sol = QgsVectorLayer("point?crs=" + layer.dataProvider().crs().authid(), "Installazioni suggerite: " + feat_key, "memory")
            pr = layer_sol.dataProvider()

            pr.addAttributes(attr)
            layer_sol.updateFields()

            for tup in sol['nodes'][feat_key]:

                feat = QgsFeature()

                feature = tup[3]

                feat.setAttributes(feature.attributes())
                feat.setGeometry(feature.geometry())
                pr.addFeatures([feat])

            QgsProject.instance().addMapLayer(layer_sol, False)

            treelayer = QgsLayerTreeLayer(layer_sol)
            solgroup.insertChildNode(0, treelayer)

        layer_name = {"trail":   self.modeldlg.trailLineLayer.currentText(),
                      "canal":   self.modeldlg.canalLineLayer.currentText(),
                      "railway": self.modeldlg.railwayLineLayer.currentText()}

        # Add edge layers
        for feat_key in sol['edges']:

            if len(sol['edges'][feat_key]) == 0:
                continue

            layer = QgsProject.instance().mapLayersByName(layer_name[feat_key])[0]
            attr = layer.dataProvider().fields().toList()

            layer_sol = QgsVectorLayer("linestring?crs=" + layer.dataProvider().crs().authid(), "Installazioni suggerite: " + feat_key, "memory")
            pr = layer_sol.dataProvider()
            pr.addAttributes(attr)
            layer_sol.updateFields()

            symbol = QgsLineSymbol()
            symbol.setWidth(1.24)
            symbol.setColor(QColor.fromRgb(250,50,200) if feat_key == 'trail' else QColor.fromRgb(50,150,250))
            layer_sol.renderer().setSymbol(symbol)

            for tup in sol['edges'][feat_key]:

                feat = QgsFeature()

                feature = tup[5]

                if feat_key == 'trail' and \
                   ((feature['LAYER'] != None and
                     feature['LAYER'] != 'percorsi di progetto' and
                     feature['LAYER'] != 'Percorsi di progetto')):
                    continue

                feat.setAttributes(feature.attributes())
                feat.setGeometry(feature.geometry())
                pr.addFeatures([feat])

            QgsProject.instance().addMapLayer(layer_sol, False)

            treelayer = QgsLayerTreeLayer(layer_sol)
            solgroup.insertChildNode(0, treelayer)

        add_cumul_flow_layer(solgroup, sol['flow']['canal'], self.modeldlg.canalLineLayer.currentText(), 'canali')
        add_cumul_flow_layer(solgroup, sol['flow']['trail'], self.modeldlg.trailLineLayer.currentText(), 'ciclabili')
        add_cumul_flow_layer(solgroup, sol['flow']['railway'], self.modeldlg.railwayLineLayer.currentText(), 'ferrovie')


    def run(self):
        """Run method that performs all the real work"""

        # Fetch the currently loaded layers
        layers = QgsProject.instance().layerTreeRoot().children()

        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        if self.first_start == True:
            self.first_start = False
            self.modeldlg = UrbanOptiPluginDialog()
            # self.modeldlg.pushButton.clicked.connect(self.select_output_file)

            # Clear the contents of the comboBox from previous runs
            self.modeldlg.criterio.clear()
            self.modeldlg.criterio.addItems(['Max. flusso canali/ciclabili',
                                             'Max. num. percorsi',
                                             'Costo totale minimo'])

        layernames = get_layer_names(QgsProject.instance().layerTreeRoot())
        layernames.sort()

        for selector in [
                self.modeldlg.canalLineLayer,
                self.modeldlg.canalPointLayer,
                self.modeldlg.trailLineLayer,
                self.modeldlg.trailPointLayer,
                self.modeldlg.railwayLineLayer,
                self.modeldlg.railwayPointLayer,
                self.modeldlg.trafficLayer]:

            selector.clear()
            selector.addItems(layernames)

        # Show the model dialog
        self.modeldlg.show()

        # Run the dialog event loop
        result = self.modeldlg.exec_()

        # See if OK was pressed
        if not result:
            return

        # logfile = self.modeldlg.output_file.text()

        if self.modeldlg.budget.text() == '':
            budget = None
        else:
            try:
                budget = int(self.modeldlg.budget.text())
            except ValueError as e:
                # Read data from appropriate layers
                self.iface.messageBar().pushMessage(
                    "Error", "Please specify budget as number without unit",
                    level=Qgis.Info, duration=1)
                raise e

        criterionIndex = self.modeldlg.criterio.currentIndex()

        # Read data from appropriate layers
        self.iface.messageBar().pushMessage(
            "Info", "Reading data from layers",
            level=Qgis.Info, duration=1)

        self.modeldlg.trafficLayer.setCurrentText("AirbreakOD-line")

        self.modeldlg.trailPointLayer.setCurrentText("Infrastrutture-Point")
        self.modeldlg.trailLineLayer.setCurrentText("Ciclabili-linestring")

        self.modeldlg.railwayPointLayer.setCurrentText("MetropoliPaesaggio_masterplan:Stazioni_ferroviarie")
        self.modeldlg.railwayLineLayer.setCurrentText("ferrovie-linestring")

        self.modeldlg.canalPointLayer.setCurrentText("Approdi - potenziali \"fermate d'acqua\" Fermate acqua")
        self.modeldlg.canalLineLayer.setCurrentText("Canali-linestring")

        # Read network data from QGIS interface
        netdata = UrbanData(self.iface,
                            area='region',

                            trafficLayer =      self.modeldlg.trafficLayer.currentText(),
                            trafficOD =         self.modeldlg.demandTypeOD.isChecked(),

                            trailPointLayer =   self.modeldlg.trailPointLayer.currentText(),
                            trailLineLayer =    self.modeldlg.trailLineLayer.currentText(),
                            trailAccess =       self.modeldlg.trailAccess.isChecked(),

                            railwayPointLayer = self.modeldlg.railwayPointLayer.currentText(),
                            railwayLineLayer =  self.modeldlg.railwayLineLayer.currentText(),
                            railwayAccess =     self.modeldlg.railwayAccess.isChecked(),

                            canalPointLayer =   self.modeldlg.canalPointLayer.currentText(),
                            canalLineLayer =    self.modeldlg.canalLineLayer.currentText(),
                            canalAccess =       self.modeldlg.canalAccess.isChecked()
        )

        self.iface.messageBar().pushMessage(
            "Info", "Analyze network data",
            level=Qgis.Info, duration=1)

        # Create optimization model
        optmodel = OptModel(netdata.instance())

        if criterionIndex == 0:
            criterion = 'max_traffic'
        elif criterionIndex == 1:
            criterion = 'max_pairs'
        else:
            criterion = 'min_cost'

        self.iface.messageBar().pushMessage(
            "Info", "Create optimization model",
            level=Qgis.Info, duration=1)

        optmodel.formulate(budget=budget,
                           objective=criterion,
                           min_demands=.2,
                           min_traffic=.2)

        # Solve optimization model
        self.iface.messageBar().pushMessage(
            "Info", "Solve optimization model",
            level=Qgis.Info, duration=1)

        sol = optmodel.solve()

        if sol is not None:

            demlist = netdata.instance()['demand']

            npaths = len(demlist)
            tottraf = sum(d[4] for d in demlist)

            self.iface.messageBar().pushMessage(
                "Info", f"Costo: {sol['cost']}, Percorsi instradati: {sol['#paths']}/{npaths}, Traffico: {sol['traffic']}/{tottraf}",
                level=Qgis.Info, duration=1)

            # Create new layers from solution
            self.iface.messageBar().pushMessage(
                "Info", "Representing solution on new layer",
                level=Qgis.Info, duration=1)

            self.addSolutionLayer(sol)

        else:

            # Create new layers from solution
            self.iface.messageBar().pushMessage(
                "Info", "No solution was found. Budget insufficient or requested traffic too tight.",
                level=Qgis.Info, duration=1)
